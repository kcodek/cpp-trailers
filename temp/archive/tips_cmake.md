#### CMake
    
    @ ~/coding/cpp-coding/Projects/SimpleSocialNetwork  
    ➜  cmake -S . -B build 

    @ ~/coding/cpp-coding/Projects/SimpleSocialNetwork/build  
    ➜  make  
----
__commands__
* Scripting commands change state of command processor • set variables
    * change behavior of other commands
* Project commands
    * create build targets
    * modify build targets
* Command invocations are not expressions.
----
__Variables__
* Setwiththeset()command.
* Expandwith${}.
* Variables and values are strings.
* Lists are ;-separated strings.
* CMake variables are not environment variables (unlike Makefile).
* Unset variable expands to empty string.
----
__generator expressions__
* Generator expressions use the $<> syntax.
* Not evaluated by command interpreter. It is just a string with $<>.
* Evaluated during build system generation.
* Not supported in all commands (obviously).

----
__custom commmands__
* Commands can be added with function() or macro().
    - Difference is like in C++.
    - When a new command replaces an existing command, the old one can be accessed with a _ prefix.

* Create macros to wrap commands that have output parameters. Otherwise, create a function.
----
__Targets and  Properties__

_Imagine Targets as Objects_
* Constructors:
    - add_executable()
    - add_library()
* Member variables:
    - Target properties (too many to list here).
* Member functions:
    - get_target_property()
    - set_target_properties()
    - get_property(TARGET)
    - set_property(TARGET)
    - target_compile_definitions()
    - target_compile_features()
    - target_compile_options()
    - target_include_directories()
    - target_link_libraries()
    - target_sources()

__Build Specification and Usage Requirements__
* Non-INTERFACE_properties define the build specification of a target.
* INTERFACE_ properties define the usage requirements of a target.
- PRIVATE populates the non-INTERFACE_ property. 
- INTERFACE populates the INTERFACE_ property.
- PUBLIC populates both.

* Use *target_link_libraries()* to express direct dependencies!
* INTERFACE libraries have no build specification. They only have usage requirements 

__How to use external libraries__
* Use a *Find* module for third party libraries that are do not support clients to use CMake

__CPack__
* CPack is a packaging tool distributed with CMake.
* set() variables in CPackConfig.cmake, or
* set() variables in CMakeLists.txt and include(CPack).
* Write your own CPackConfig.cmake and include() the one that is generated by CMake.

* The variable CPACK_INSTALL_CMAKE_PROJECTS is a list of quadruples:
    1. Build directory
    2. Project Name
    3. Project Component 
    4. Directory
----

__CTest__

----
__Cross Compiling__
__Toolchain.cmake__     

    set(CMAKE_SYSTEM_NAMEWindows)      
    set(CMAKE_C_COMPILER x86_64-w64-mingw32-gcc)       
    set(CMAKE_CXX_COMPILERx86_64-w64-mingw32-g++)   
    set(CMAKE_RC_COMPILER x86_64-w64-mingw32-windres)   
    set(CMAKE_FIND_ROOT_PATH/usr/x86_64-w64-mingw32)    
    set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAMNEVER) 
    set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARYONLY)  
    set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDEONLY)  
    set(CMAKE_CROSSCOMPILING_EMULATORwine64)    

* Don’t put logic in toolchain files.
