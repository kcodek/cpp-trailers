cmake_minimum_required(VERSION 3.10 FATAL_ERROR) 
# set(CMAKE_LEGACY_CYGWIN_WIN32 0)

project("To Do List")

list(APPEND CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake/Modules)

enable_testing()
include(gmock)

if (NOT DEFINED     BOOST_ROOT        AND
    NOT DEFINED ENV{BOOST_ROOT}       AND
    NOT DEFINED     BOOST_INCLUDEDIR  AND
    NOT DEFINED ENV{BOOST_INCLUDEDIR} AND
    NOT DEFINED     BOOST_LIBRARYDIR  AND
    NOT DEFINED ENV{BOOST_LIBRARYDIR})
    if (APPLE)
        # set(BOOST_ROOT "../../../boost/boost_1_54_0/mac")
        set(BOOST_ROOT "/usr/local/opt/boost@1.67/include/boost")
    elseif (WIN32)
        set(BOOST_INCLUDEDIR "C:/local/boost_1_55_0")
        set(BOOST_LIBRARYDIR "C:/local/boost_1_55_0/lib32-msvc-10.0")
    endif()
endif()
if (APPLE OR WIN32)
    set(Boost_USE_STATIC_LIBS TRUE)
endif()
find_package(Boost 1.67 REQUIRED COMPONENTS program_options)
include_directories(SYSTEM ${Boost_INCLUDE_DIRS})


if ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU" OR
    "${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang")
    set(warnings "-Wall -Wextra -Werror")
elseif ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "MSVC")
    set(warnings "/W4 /WX /EHsc")
     # Disabled Warnings:
        #   4512 "assignment operator could not be generated"
        #        This warning provides no useful information and will occur in
        #        well formed programs.
        #        <http://msdn.microsoft.com/en-us/library/hsyx7kbz.aspx>
endif()

if (NOT CONFIGURED_ONCE)
    set(CMAKE_CXX_FLAGS "${warnings}"
        CACHE STRING "Flags used by the compiler during all build types." FORCE)
    set(CMAKE_C_FLAGS   "${warnings}"
        CACHE STRING "Flags used by the compiler during all build types." FORCE)
endif()

include_directories(${CMAKE_CURRENT_SOURCE_DIR}) 
add_subdirectory(ToDoCore)

add_executable(toDo main.cpp)
target_link_libraries(toDo toDoCore)

add_test(toDoTest toDo)

set(CONFIGURED_ONCE TRUE CACHE INTERNAL
    "A flag showing that CMake has configured at least once.")



# CMAKE_CURRENT_SOURCE_DIR - The full path to the source directory that CMake is currently processing.

# include_directories(directories) - Add 'directories' to the end of this directory’s include paths.

# include_directories(AFTER|BEFORE SYSTEM directory…)
    # AFTER|BEFORE - Specify whether or not these include directories should be appended or prepended to the list of include directories. If omitted then the default behavior is used.
        # By default directories are appended to the list. This behavior can be changed by setting CMAKE_INCLUDE_DIRECTORIES_BEFORE to TRUE.
    # SYSTEM - Specify that these directories are system include directories. 
        # This only has an affect on compilers that support the distinction. This can change the order in which the compiler searches include directories or the handling of warnings from headers found in these directories. 
    # directory…  The directories to be added to the list of include directories.



# add_subdirectory(source_dir) - Include the directory source_dir in your project. This directory must contain a CMakeLists.txt file.
    # Note: We’re omitting the optional second parameter. This only works with subdirectories of the current directory.

    #add_subdirectory(source_dir [binary_dir])
    #Add the directory source_dir to the current project with binary_dir as its corresponding binary output directory. 
    #When adding a directory that is a subdirectory of the current directory CMake will automatically determine what the binary output directory should be, making the second argument optional. 
    #However if you add a directory that isn’t a subdirectory you need to specify the binary output directory.


# target_link_libraries(target library…)  -  Specify that target needs to be linked against one or more libraries. If a library name matches another target dependencies are setup automatically so that the libraries will be built first and target will be updated whenever any of the libraries are.
    # If the target is an executable then it will be linked against the listed libraries.
    # If the target is a library then its dependency on these libraries will be recorded. Then when something else links against target it will also link against target‘s dependencies. This makes it much easier to handle a library’s dependencies since you only have to define them once when you define library itself.

    

#add_library(target STATIC | SHARED | MODULE sources…)
    # This command creates a new library target built from sources. As you may have noticed this command is very similar to add_executable.
    # With STATIC, SHARED, and MODULE you can specify what kind of library to build. 
        #STATIC libraries are archives of object files that are linked directly into other targets. 
        #SHARED libraries are linked dynamically and loaded at runtime. 
        #MODULE libraries are plug-ins that aren’t linked against but can be loaded dynamically at runtime.
    # If the library type is not specified it will be either STATIC or SHARED. 
    # The default type is controlled by the BUILD_SHARED_LIBS variable. By default static libraries are created.    


#CMAKE_BINARY_DIR - This variable holds the path to the top level binary output directory, i.e. the directory in which you ran the cmake command or the path you chose for “Where to build the binaries” in the GUI.